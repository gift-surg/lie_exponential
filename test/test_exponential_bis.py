"""
Test exponential_new_new maps for the linear case.
Compare it with the old exponential_new.
"""

"""
Module for the computation of 2d SVF generated with matrix of se2_a.
The exponential_new of the SVFs is then computed and compared with the stationary
displacement field SDISP generated by the closed for of the exponential_new of the
se2_a matrix in se2_g.
Here for only 1 sfv, step by step.
In main_matrix_generated_multiple the same for an arbitrary number of svf
generated by matrix, with random input parameters.
"""

import numpy as np
import matplotlib.pyplot as plt

from transformations.s_vf import SVF
from transformations.s_disp import SDISP

from transformations.se2_a import se2_g

from visualizer.fields_at_the_window import see_field
from visualizer.fields_comparisons import see_overlay_of_n_fields, \
    see_2_fields_separate_and_overlay, see_n_fields_separate, see_n_fields_special

'''
### compute matrix of transformations:
domain = (14, 14)

x_c = 7
y_c = 7
theta = np.pi/4

tx   = (1 - np.cos(theta)) * x_c + np.sin(theta) * y_c
ty   = -np.sin(theta) * x_c + (1 - np.cos(theta)) * y_c

passepartout = 2

m_0 = se2_g.se2_g(theta, tx, ty)
dm_0 = se2_g.log(m_0)

print dm_0.get_matrix
print m_0.get_matrix


### generate subsequent vector fields
svf_0   = SVF.generate_from_matrix(domain, dm_0.get_matrix, affine=np.eye(4))
sdisp_0 = SDEF.generate_from_matrix(domain, m_0.get_matrix - np.eye(3), affine=np.eye(4))


print svf_0.lagrangian_coordinate_system
print sdisp_0.lagrangian_coordinate_system

print type(svf_0)
print type(sdisp_0)


### compute exponential_new with different available methods:
spline_interpolation_order = 3

sdisp_ss = svf_0.exponential_new(algorithm='ss', s_i_o=spline_interpolation_order)

sdisp_ss.lagrangian_coordinate_system = True

print '--------------------'
print "Norm of the svf:"
print svf_0.norm(passe_partout_size=4)

print '--------------------'
print "Norm of the displacement field:"
print sdisp_0.norm(passe_partout_size=4)


print '--------------------'
print "Norm of the errors:"
print '--------------------'

print '|ss - disp|        = ' + str((sdisp_ss - sdisp_0).norm(passe_partout_size=passepartout))

print


### Plot:

fields_list = [svf_0, sdisp_0, sdisp_ss]
title_input = ['svf_0', 'sdisp_0', 'sdisp_ss']
input_color = ['r', 'b', 'g', 'c', 'm', 'k', 'b', 'g', 'c']


if 1:
    title_input_l = ['Sfv Input',
                     'Ground Output',
                     'Scaling and Squaring',
                     'Polyaffine Scal. and Sq.',
                     'Euler method',
                     'Midpoint',
                     'Euler Modif',
                     'Heun',
                     'Heun Modif',
                     'Runge Kutta 4']

    list_fields_of_field = [[svf_0], [sdisp_0]]
    list_colors = ['r', 'b']
    for third_field in fields_list[2:]:
        list_fields_of_field += [[svf_0, sdisp_0, third_field]]
        list_colors += ['r', 'b', 'm']

    see_n_fields_special(list_fields_of_field, fig_tag=50,
                         colors_input=list_colors,
                         titles_input=title_input_l,
                         sample=(1, 1),
                         zoom_input=[0, 14, 0, 14],
                         window_title_input='matrix, random generated',
                         legend_on=False)

if 0:
    title_input_l = ['Scaling and Squaring',
                     'Polyaffine Scaling and Squaring',
                     'Euler method',
                     'Series',
                     'Midpoint Method',
                     'Euler Modif Method',
                     'Runge Kutta 4']

    for k, third_field in enumerate(fields_list[2::]):
        see_overlay_of_n_fields([svf_0, sdisp_0, third_field], fig_tag=20 + k,
                                title_input=title_input_l[k],
                                input_color=['r', 'b', 'm'],
                                window_title_input='matrix, random generated')


plt.show()
'''


