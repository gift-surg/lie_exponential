"""
Module for the computation of 2d SVF generated with matrix of se2_a.
The exponential of the SVFs is then computed and compared with the stationary
displacement field SDISP generated by the closed form of the exponential of the
se2_a matrix in se2_g.
Here for only 1 sfv, step by step.
In main_matrix_generated_multiple the same for an arbitrary number of svf
generated by matrix, with random input parameters.
"""

import numpy as np
import matplotlib.pyplot as plt
import time


from transformations.s_vf import SVF
from transformations.s_disp import SDISP

from transformations.se2_a import se2_g

from visualizer.fields_comparisons import see_overlay_of_n_fields, \
    see_2_fields_separate_and_overlay, see_n_fields_separate, see_n_fields_special
from visualizer.graphs_and_stats import custom_boxplot


### compute matrix of transformations:


# -----------------
# Control panel:
domain = (16, 16)  # Matrix coordinates: x = -Y, y = X
passe_partout_size = 2
omega = (5, 11, 5, 11)  # where to locate the center of the random rotation

interval_theta = (- np.pi / 4, np.pi / 4)
epsilon = 0.01
#interval_tx    = [-8, ]
#interval_ty    = [8, ]
spline_interpolation_order = 3

N = 50
verbose = True
all_plot = False
# -----------------

# TODO correct boxplot with new cases!

# output data structure:
res = np.zeros([N, 10])
res_t = np.zeros([N, 8])

for i in range(N):

    print '--------------------'
    print '--------------------'
    print 'Step: ' + str(i) + '/' + str(N)

    ### Generate random matrix of transformations:

    m_0 = se2_g.randomgen_custom_center(interval_theta=interval_theta,
                                        omega=omega,
                                        epsilon_zero_avoidance=epsilon)
    dm_0 = se2_g.log(m_0)

    ### generate subsequent vector fields

    svf_0   = SVF.generate_from_matrix(domain, dm_0.get_matrix, affine=np.eye(4))
    sdisp_0 = SDISP.generate_from_matrix(domain, m_0.get_matrix - np.eye(3), affine=np.eye(4))

    # different number of steps per methods
    steps_per_method = [7, 1, 40, 10, 10, 10, 10, 1]
    #steps_per_method = [None, ]*8  # default number of steps

    ### compute exponential with different available methods:
    start = time.time()
    sdisp_ss      = svf_0.exponential(algorithm='ss',
                                      s_i_o=spline_interpolation_order,
                                      input_num_steps=steps_per_method[0])
    res_t[i, 0] = (time.time() - start)

    start = time.time()
    sdisp_ss_pa   = svf_0.exponential(algorithm='ss_pa',
                                      s_i_o=spline_interpolation_order,
                                      input_num_steps=steps_per_method[1])
    res_t[i, 1] = (time.time() - start)

    start = time.time()
    sdisp_euler   = svf_0.exponential(algorithm='euler',
                                      s_i_o=spline_interpolation_order,
                                      input_num_steps=steps_per_method[2])
    res_t[i, 2] = (time.time() - start)

    start = time.time()
    sdisp_mid_p   = svf_0.exponential(algorithm='midpoint',
                                      s_i_o=spline_interpolation_order,
                                      input_num_steps=steps_per_method[3])
    res_t[i, 3] = (time.time() - start)

    start = time.time()
    sdisp_euler_m = svf_0.exponential(algorithm='euler_mod',
                                      s_i_o=spline_interpolation_order,
                                      input_num_steps=10)
    res_t[i, 4] = (time.time() - start)

    start = time.time()
    sdisp_heun    = svf_0.exponential(algorithm='heun',
                                      s_i_o=spline_interpolation_order,
                                      input_num_steps=10)
    res_t[i, 5] = (time.time() - start)

    start = time.time()
    sdisp_heun_m  = svf_0.exponential(algorithm='heun_mod',
                                      s_i_o=spline_interpolation_order,
                                      input_num_steps=10)
    res_t[i, 6] = (time.time() - start)

    start = time.time()
    sdisp_rk4     = svf_0.exponential(algorithm='rk4',
                                      s_i_o=spline_interpolation_order,
                                      input_num_steps=10)
    res_t[i, 7] = (time.time() - start)

    ### store data:

    res[i, 0] = svf_0.norm(passe_partout_size=passe_partout_size)
    res[i, 1] = sdisp_0.norm(passe_partout_size=passe_partout_size)
    res[i, 2] = (sdisp_ss - sdisp_0).norm(passe_partout_size=passe_partout_size)       # |ss - disp|
    res[i, 3] = (sdisp_ss_pa - sdisp_0).norm(passe_partout_size=passe_partout_size)    # |ss_pa - disp|
    res[i, 4] = (sdisp_euler - sdisp_0).norm(passe_partout_size=passe_partout_size)    # |euler - disp|
    res[i, 5] = (sdisp_mid_p - sdisp_0).norm(passe_partout_size=passe_partout_size)    # |midpoint - disp|
    res[i, 6] = (sdisp_euler_m - sdisp_0).norm(passe_partout_size=passe_partout_size)  # |euler_mod - disp|
    res[i, 7] = (sdisp_heun - sdisp_0).norm(passe_partout_size=passe_partout_size)     # |heun - disp|
    res[i, 8] = (sdisp_heun_m - sdisp_0).norm(passe_partout_size=passe_partout_size)   # |heun_mod - disp|
    res[i, 9] = (sdisp_rk4 - sdisp_0).norm(passe_partout_size=passe_partout_size)      # |rk4 - disp|

    if verbose:  # Verbose: print the errors of each methods:
        print '--------------------'
        print 'generated matrix parameters:'
        print 'theta, tx, ty =    ' + str(m_0.get)
        print 'dtheta, dtx, dty = ' + str(dm_0.get)

        print '--------------------'
        print "Norm of the svf:"
        print res[i, 0]

        print '--------------------'
        print "Norm of the displacement field:"
        print res[i, 1]

        print '--------------------'
        print "Norm of the errors:"
        print '|ss - disp|        = ' + str(res[i, 2])
        print '|ss_pa - disp|     = ' + str(res[i, 3])
        print '|euler - disp|     = ' + str(res[i, 4])
        print '|midpoint - disp|  = ' + str(res[i, 5])
        print '|euler_mod - disp| = ' + str(res[i, 6])
        print '|heun - disp|      = ' + str(res[i, 7])
        print '|heun_mod - disp|  = ' + str(res[i, 8])
        print '|rk4 - disp|       = ' + str(res[i, 9])
        print

    if all_plot:  # show images of each field

        title_input_l = ['Sfv Input',
                         'Ground Output',
                         'Scaling and Squaring',
                         'Polyaffine Scal. and Sq.',
                         'Euler method',
                         'Midpoint Method',
                         'Euler Modif Method',
                         'Heun',
                         'Heun Modif',
                         'Runge Kutta 4']

        list_fields_of_field = [[svf_0], [sdisp_0]]
        list_colors = ['r', 'b']
        fields_list = [svf_0, sdisp_0, sdisp_ss,   sdisp_ss_pa,   sdisp_euler,
                       sdisp_mid_p,   sdisp_euler_m, sdisp_heun, sdisp_heun_m,  sdisp_rk4]
        for third_field in fields_list[2:]:
            list_fields_of_field += [[svf_0, sdisp_0, third_field]]
            list_colors += ['r', 'b', 'm']

        see_n_fields_special(list_fields_of_field, fig_tag=10 + i,
                             colors_input=list_colors,
                             titles_input=title_input_l,
                             zoom_input=[0, 16, 0, 16], sample=(2, 2),
                             window_title_input='matrix, random generated' + str(i),
                             legend_on=False)


mean_time = np.mean(res_t, axis=0)

print "Mean time per methods:"
print mean_time

if 1:  # Print boxplot!

    reordered_data_for_boxplot = [list(res[:, 2])] +\
        [list(res[:, 3])] + [list(res[:, 4])] + [list(res[:, 5])] + [list(res[:, 6])] +\
        [list(res[:, 7])]  + [list(res[:, 8])] + [list(res[:, 9])]

    title_input_l = ['Sca and Sq',
                     'Poly Sca and Sq',
                     'Euler method',
                     'Midpoint ',
                     'Euler mod',
                     'Heun',
                     'Heun mod',
                     'Runge Kutta 4']

    custom_boxplot(reordered_data_for_boxplot, x_labels=title_input_l, fig_tag=2,
                   add_extra_numbers=mean_time)


plt.show()

