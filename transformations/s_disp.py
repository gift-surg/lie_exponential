"""
Class for stationary displacement fields.
Image of SVF through the exponential map.
"""
import numpy as np
import nibabel as nib

import warnings

from utils.image import Image


class SDISP(Image):

    ### SDISP manager methods  ###

    def __init__(self, input_nifti_image):
        """
        From nifti_image to S_DEF: stationary deformation field.
        Discretisation of an element in the Lie group of diffeomorphims, defined as
                         \varphi(x)   in Eulerian coordinates
                         or
                         \varphi(x) - x   in Lagrangian coordinates
        for each point in the grid Omega that represents the discretised domain.
        By default SDISP are initialized with nifti images of adequate shape.
        The difference with class IMAGE is not in the attributes
        but in the methods:
        an stationary displacement field can access more operations respect to the IMAGE, and
        get a warning when a sum or a scalar multiplication and norm are performed (since they
        are improperly defined on a structure of group).
        """
        if len(input_nifti_image.get_data().shape) == 5:
            if input_nifti_image.get_data().shape[3] == 1:  # time points
                super(SDISP, self).__init__(input_nifti_image)
            else:
                raise TypeError('Inserted nifty images does not corresponds to a stationary vector field')
        else:
            raise TypeError('Inserted nifty images does not corresponds to a vector field')

    @classmethod
    def from_nifti_image(cls, input_nifti_image):
        """
        Redundant version of the __init__ that creates object svf from nifti_image.
        Just to remember who is the input for the initialization.
        :param input_nifti_image: input nifti image from which we want to obtain the SVF.
        """
        return cls(input_nifti_image)

    @classmethod
    def from_image(cls, input_image):
        """
        Create object from element of the class Image.
        :param input_nifti_image: input nifti image from which we want to compute the image.
        """
        return cls(input_image.nib_image)

    @classmethod
    def from_array(cls, array, affine=np.eye(4), homogeneous=False):
        image = nib.Nifti1Image(array, affine=affine)
        return cls(image)

    ### Generator methods ###

    '''
    @classmethod
    def generate_from_matrix(cls, input_vol_ext, input_transformation, affine=np.eye(4), header=None,
                             lagrangian_coordinates=True):
        """
        A vector field generated by a matrix of se2_g is in Eulerian coordinates.
        A vector field generated by a matrix of se2_a is in Lagrangian coordinates.
        """
        # test matrix is in se2_a or se3_a.
        if input_transformation.__class__.__name__ == 'se2_g' or input_transformation.__class__.__name__ == 'se3_g':
            field = Field.generate_from_matrix(input_vol_ext=input_vol_ext,
                                               input_matrix=input_transformation.get_matrix,
                                               lagrangian_coordinates=False)

            return cls.from_field(field)
        else:
            raise TypeError('input matrix must be an element of se_2 or se_3, according to the dimension.')
    '''
    ### inhibition of sum, scalar prod and norm inherited from Image

    def __add__(self, other, warn=False):
        # TODO refactor add sub and rmul:  they must be classmethod only in field and image.
        return SDISP.from_array_with_header(self.field + other.field,
                                            self.nib_image.get_header(),
                                            affine=self.voxel_2_mm)

    def __sub__(self, other, warn=False):
        return SDISP.from_array_with_header(self.field - other.field,
                                            self.nib_image.get_header(),
                                            affine=self.voxel_2_mm)

    def __rmul__(self, alpha, warn=False):
        return SDISP.from_array_with_header(alpha * self.field,
                                            self.nib_image.get_header(),
                                            affine=self.voxel_2_mm)

    def norm(self, passe_partout_size=1, normalized=True, warn=False):
        if warn:
            warnings.warn('The norm of a displacement field is computed improperly. '
                          'Resulting numerical computations are likely to be meaningless.')
        return super(SDISP, self).norm(passe_partout_size=passe_partout_size, normalized=normalized)

    ### Advanced methods (exp and log and related) ###

    def logarithm(self, kind=''):
        pass

    @classmethod
    def exp_sum(cls, left, right):
        if not left.dim == right.dim:
            raise TypeError('Input fields must have the same dimension')

        field_result = left.field + right.field

        return cls(nib.Nifti1Image(field_result, np.eye(4)))

    @classmethod
    def exp_scalar_product(cls, left, right):
        if not left.dim == right.dim:
            raise TypeError('Input fields must have the same dimension')

        field_result = left.field + right.field

        return cls(nib.Nifti1Image(field_result, np.eye(4)))



